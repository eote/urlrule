#!/usr/bin/perl -w
###APPNAME:     urlrule_action
###APPAUTHOR:   eotect@myplace
###APPDATE:		Mon Mar 24 06:25:31 2008
###APPVER:		1.0
###APPDESC:     apply rule for URL,and perform action	
###APPUSAGE:	urlrule_action URL [0-5] [action args...]
###APPEXAMPLE:	urlrule_action http://www.sina.com.cn 0 cat
use strict;
use utf8;
binmode STDOUT,':utf8';
binmode STDERR,':utf8';
binmode STDIN,':utf8';
our $VERSION = 'v0.1';

#GLOBAL VARAIBLE
my @OPTIONS;
my %OPTS;
my $CONF;
my $RULE;
my $PROGRAM;
my $HISTORY;
my $URLIGNORE;
my $CWD;
my $MSG;


sub after_apply_rule {
	my $status = shift;
	my $result = shift;
	my $rule = shift;
	if($result && ref $result && !$result->{error}) {
		if($rule->{level} <= $OPTS{test}) {
			if($result->{pass_data} && @{$result->{pass_data}}) {
				my $pcount = @{$result->{pass_data}};
				my $ccount = 1;
				if($ccount < $pcount) {
					$MSG->warn("TEST MODE: trim PASS_DATA from <$pcount> down to <$ccount>\n");
					$result->{pass_data} = [@{$result->{pass_data}}[0 .. $ccount-1]];
				}
			}
		}
	}
	return $status,$result;
}

sub process_passdown {
	my ($resp) = @_;
    my $CWD = getcwd();
	$PROGRAM->push($CWD,'load_rule',@{$resp}{qw/title url level action/});
}

sub load_rule {
    my $CWD = getcwd();
	my ($title,$url,$level,$action) = @_;
	my $rep = $url . ($level ? "|$level" : "");
	if($URLIGNORE->check($rep)) {
		$MSG->message("Ignored: $rep\n");
		return 1;
	}
	if(!$OPTS{"no-history"}) {
		if($action && (!$level)) {
			if($HISTORY->check($url)) {
				$MSG->message("Ignored, URL'd been processed. $url\n");
				return;
			}
		}	
	}
	my $status = $RULE->autoApply($url,$level,$action,$title);
	if(!$OPTS{"no-history"}) {
		if($status && (!$level)) {
			$HISTORY->save($url);
		}
	}
    chdir $CWD;
}

sub sig_killed {
	if(!$OPTS{"no-history"}) {
		$HISTORY->write();
	}
    $MSG->message("Saving remained tasks...\n");
    if($PROGRAM->{lastStack}) {
        $PROGRAM->unshift(@{$PROGRAM->{lastStack}});
    }
    chdir($CWD) if($CWD);
    $PROGRAM->saveToFile();
    $MSG->message($PROGRAM->length," tasks saved for resuming\n");
    exit 1;
}

sub set_options {
	my @ARGV = @_;
	die(join("\t",@ARGV));
	return @ARGV;
}

# INIT
use MyPlace::Script::Message;
use MyPlace::URLRule::OO;
use MyPlace::URLRule::Config;
use Cwd qw/getcwd/;
@OPTIONS = qw/
	help|h|? 
	manual|man
    verbose|v:i
	no-history|nh
	test|t:i
/;
if(@ARGV) {
	require Getopt::Long;
	Getopt::Long::GetOptions(\%OPTS,@OPTIONS);
}
if($OPTS{'help'} or $OPTS{'manual'}) {
	require Pod::Usage;
	my $v = $OPTS{'help'} ? 1 : 2;
	Pod::Usage::pod2usage(-exitval=>$v,-verbose=>$v);
    exit $v;
}

$CONF = MyPlace::URLRule::Config->new();
$PROGRAM = $CONF->resume();
if(@ARGV) {
    $PROGRAM->push($CWD,'load_rule',undef,@ARGV);
}
else {
    $PROGRAM->loadFromFile();
	my $opts = $PROGRAM->getState("OPTIONS");
	if($opts) {
		%OPTS = (
			%{$opts},
			%OPTS,
		);
	}
	$PROGRAM->setState("OPTIONS",\%OPTS);
	if(!$PROGRAM->length) {
		print STDERR "Nothing to resume\n";
		print STDERR "Read tasks from STDIN...\n";
		while(<STDIN>) {
			chomp;
			my $line = shift;
			my @args = split($line,"\t");
			$PROGRAM->push($CWD,'load_rule',undef,@args);
		}
	}
}
$RULE = new MyPlace::URLRule::OO(
		buildurl=>1,
		createdir=>1,
		callback_nextlevel=>\&process_passdown,
);
my $appname = $0;
$appname =~ s/^.+\///;
$MSG = MyPlace::Script::Message->new($appname);
$CWD = getcwd();

if($OPTS{test}) {
	$OPTS{'no-history'} = 1;
	$RULE->{request}->{AfterApplyRule} = \&after_apply_rule;
}

if(!$OPTS{'no-history'}) {
	$HISTORY = $CONF->history;
	$HISTORY->load();
}
$URLIGNORE = $CONF->ignore();
$URLIGNORE->load();
$URLIGNORE->close();

$SIG{INT} = \&sig_killed;

my $TASKSDONE = 0;
while(my $tasks = $PROGRAM->length) {
    $MSG->blue("[$tasks] tasks remained\n");
    $PROGRAM->run();
	$TASKSDONE++;
	if(($TASKSDONE % 19) == 0) {
	    $PROGRAM->saveToFile();
		$MSG->green($PROGRAM->length . " tasks AUTO saved.\n");
	}
}
$MSG->message("All tasks completed.\n");
if(!$OPTS{"no-history"}) {
	$HISTORY->save_last();
	$HISTORY->write();
}
exit 0;
